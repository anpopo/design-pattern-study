# 디자인 패턴 학습 with 자바

**디자인 패턴을 배우고 학습하기 위해 시작**

## 1. Iterator 패턴
- 반복자 패턴
  - 무엇인가 많이 모여있는 것들을 순서대로 지정해 전체를 검색 처리 하기 위한 것
- interface Aggregate
  - 실질적인 반복을 하기 위해 필요한 객체(a)를 모아둔 집합체를 관리하는 객체(b)
    - 예를 들면 책(a)을 모아둔 서가(b), 동영상 파일(a)을 모아둔 폴더(b) 등
  - iterator()
    - Iterator 인터페이스를 구현하고 있는 구현체 클래스를 얻음.

- interface Iterator
  - 반복을 위해 사용되어 지는 인터페이스
  - **구현과 분리된 부분에서 메소드를 하나씩 세어 나갈 수 있는 이점이 있음**
    - **반복되는 부분과 실질적으로 구현하는 부분이 분리되기 때문에 구현부와 반복부의 결합도가 낮아진다 커몬**
  - Aggregate 를 구현한 클래스의 객체를 가지고 있음.
  - hasNext()
    - Aggregate 구현 클래스에서 다음에 있는 요소를 꺼내와도 괜찮은지 확인하는 메소드
  - next()
    - Aggregate 구현 클래스에 있는 현재 객체를 반환
    - 반환 전 내부적으로 관리되는 상태인 index 를 증가시키고 반환
    

## 2. Adapter Pattern 
- 이미 제공되고 있는 것과 필요한 것 사이의 차이를 없애주는 디자인 패턴
- 뭔가 애매하게 잘 모르겠어..
- 외국 나갈때 사용하는 돼지코 어댑터를 생각하면 이해가 편함
  - 원래 제공 되는 전기 제품이 있고 (예를들면 드라이어)
  - 110 볼트로 사용해야 되는 플러그가 있으면
  - 돼지코 어댑터에 220 볼트의 전원을 꽂아 110 볼트로 사용할 수 있다.
  - 즉, 무언가를 포장하거나 감싸서 다른 용도로 사용하게 만드는 패턴
    - 그렇기 때문에 wrapper 패턴으로 불리기도 한다.

- 포장 방법이 두가지가 있음 - 상속을 사용 /  위임을 사용
  - 상속을 사용한 패턴
    - 사용하고 있는 기능을 가진 클래스를 상속받고, 만들어야 할 기능(사용할 기능)을 가진 인터페이스를 구현
    - 해당 구현체의 메소드에서 상속받은 메소드를 사용할 수 있다.
    - 해당 클래스는 인터페이스 타입으로 인스턴스를 생성할 수 있으며,
    - 해당 인터페이스에 접근하는 클래스는 구체적으로 사용할 기능을 가진 클래스의 정보에 대해 알 수 없다. -> 이것이 멋진 포인트 예아~
  - 위임을 사용한 패턴
    - 자바에선 상속은 한개의 클래스만 받을 수 있다.
    - 만들어야할 기능(사용할 기능)을 가진 클래스를 상속받고 사용하고 있는 기능을 가진 인스턴스를 어댑터가 내부적으로 가지고 있는다.
    - 해당 클래스를 생성할때 사용할 기능을 가진 인스턴스를 새로 만들어준다.
    - 이 또한 해당 클래스가 가지고 있는 사용할 기능을 가진 인스턴스가 동작하는 행위를 알 수 없다. -> 쿨 띵~ 예아~

- 어댑터 패턴의 등장 인물들
- Target
  - 지금 사용할 기능을 가진 녀석을 결정하는 놈
- Client
  - 예제의 main 클래스
- Adapteeeee - 개조 되는 쪽
  - 사용하고 있는 기능을 가지고 있는 클래스
- Adapter
  - Target 에서 결정할 메소드를 어떻게든 사용할 수 있도록 만들어야 하는 놈
  - 어댑터에서 어떻게든 타겟이 요청한 메소드를 이미 우리가 요청한 메소드와 같이 동작하도록 해야한다.

- 왜 사용하는 것일까?!
  - 보통은 이미 만들어진 클래스를 재 사용 하기 위해 어댑터 패턴을 구현함
  - 만들어진 클래스나 소스가 없더라도 버전 호환성 문제에 사용 가능하다
    - 신 버전을 adaptee 로 사용
    - 구 버전을 target 으로 adapter 를 구현하면
    - 구버전으로 동작하는 메소드들을 신버전의 동작처럼 작동시킬 수 있다.
