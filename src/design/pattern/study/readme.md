# 디자인 패턴 학습 with 자바

**디자인 패턴을 배우고 학습하기 위해 시작**

## 1. Iterator 패턴
- 반복자 패턴
  - 무엇인가 많이 모여있는 것들을 순서대로 지정해 전체를 검색 처리 하기 위한 것
- interface Aggregate
  - 실질적인 반복을 하기 위해 필요한 객체(a)를 모아둔 집합체를 관리하는 객체(b)
    - 예를 들면 책(a)을 모아둔 서가(b), 동영상 파일(a)을 모아둔 폴더(b) 등
  - iterator()
    - Iterator 인터페이스를 구현하고 있는 구현체 클래스를 얻음.

- interface Iterator
  - 반복을 위해 사용되어 지는 인터페이스
  - **구현과 분리된 부분에서 메소드를 하나씩 세어 나갈 수 있는 이점이 있음**
    - **반복되는 부분과 실질적으로 구현하는 부분이 분리되기 때문에 구현부와 반복부의 결합도가 낮아진다 커몬**
  - Aggregate 를 구현한 클래스의 객체를 가지고 있음.
  - hasNext()
    - Aggregate 구현 클래스에서 다음에 있는 요소를 꺼내와도 괜찮은지 확인하는 메소드
  - next()
    - Aggregate 구현 클래스에 있는 현재 객체를 반환
    - 반환 전 내부적으로 관리되는 상태인 index 를 증가시키고 반환
    

## 2. Adapter Pattern 
- 이미 제공되고 있는 것과 필요한 것 사이의 차이를 없애주는 디자인 패턴
- 뭔가 애매하게 잘 모르겠어..
- 외국 나갈때 사용하는 돼지코 어댑터를 생각하면 이해가 편함
  - 원래 제공 되는 전기 제품이 있고 (예를들면 드라이어)
  - 110 볼트로 사용해야 되는 플러그가 있으면
  - 돼지코 어댑터에 220 볼트의 전원을 꽂아 110 볼트로 사용할 수 있다.
  - 즉, 무언가를 포장하거나 감싸서 다른 용도로 사용하게 만드는 패턴
    - 그렇기 때문에 wrapper 패턴으로 불리기도 한다.

- 포장 방법이 두가지가 있음 - 상속을 사용 /  위임을 사용
  - 상속을 사용한 패턴
    - 사용하고 있는 기능을 가진 클래스를 상속받고, 만들어야 할 기능(사용할 기능)을 가진 인터페이스를 구현
    - 해당 구현체의 메소드에서 상속받은 메소드를 사용할 수 있다.
    - 해당 클래스는 인터페이스 타입으로 인스턴스를 생성할 수 있으며,
    - 해당 인터페이스에 접근하는 클래스는 구체적으로 사용할 기능을 가진 클래스의 정보에 대해 알 수 없다. -> 이것이 멋진 포인트 예아~
  - 위임을 사용한 패턴
    - 자바에선 상속은 한개의 클래스만 받을 수 있다.
    - 만들어야할 기능(사용할 기능)을 가진 클래스를 상속받고 사용하고 있는 기능을 가진 인스턴스를 어댑터가 내부적으로 가지고 있는다.
    - 해당 클래스를 생성할때 사용할 기능을 가진 인스턴스를 새로 만들어준다.
    - 이 또한 해당 클래스가 가지고 있는 사용할 기능을 가진 인스턴스가 동작하는 행위를 알 수 없다. -> 쿨 띵~ 예아~

- 어댑터 패턴의 등장 인물들
- Target
  - 지금 사용할 기능을 가진 녀석을 결정하는 놈
- Client
  - 예제의 main 클래스
- Adapteeeee - 개조 되는 쪽
  - 사용하고 있는 기능을 가지고 있는 클래스
- Adapter
  - Target 에서 결정할 메소드를 어떻게든 사용할 수 있도록 만들어야 하는 놈
  - 어댑터에서 어떻게든 타겟이 요청한 메소드를 이미 우리가 요청한 메소드와 같이 동작하도록 해야한다.

- 왜 사용하는 것일까?!
  - 보통은 이미 만들어진 클래스를 재 사용 하기 위해 어댑터 패턴을 구현함
  - 만들어진 클래스나 소스가 없더라도 버전 호환성 문제에 사용 가능하다
    - 신 버전을 adaptee 로 사용
    - 구 버전을 target 으로 adapter 를 구현하면
    - 구버전으로 동작하는 메소드들을 신버전의 동작처럼 작동시킬 수 있다.


## 3. Template 패턴
- 크... 내가 좋아하는 패턴
- 상위 클래스쪽에서 템플릿에 해당하는 메소드 존재
- 하위 클래스에서 구체적인 내용을 구현하는 디자인 패턴

- 주요 등장인물은
  - AbstractClass
    - 템플릿 메소드 구현용 클래스제~
    - 템플릿에서 사용하는 추상 메소드 선언
  - ConcreteClass
    - 추상클래스에 정의된 추상 메소드를 구체적으로 구현하제~

- 왜 사용하는 것이까?
  - 템플릿 메소드에 일단 전체적인 공통 처리 순서나 알고리즘이 들어있기 때문에 유지보수 하기 편하제
  - 상위 클래스와 하위 클래스가 긴밀하게 구동되고 있다.
  - 상위 클래스의 변수에 하위 클래스의 어떠한 인스턴스를 대입해도 제대로 작동할 수 있도록 해야한다.


## 4. Factory Method 패턴
- Template Method Pattern 을 인스턴스의 생성에 적용한 디자인 패턴
  - 인스턴스를 만드는 방법을 상위 클래스에서 결정
  - 구체적인 클래스 이름은 모두 하위 클래스에서 수행
- framework 패키지의 Factory 클래스의 인스턴스 생성 메소드를 봐보자.
  - **new 를 사용해서 인스턴스를 생성하는 대신에 인스턴스 생성을 위한 메소드를 호출해 구체적인 클래스에 대한 결합을 줄이고 상위클래스를 자유롭게 했다.**
  - -> 이게 진짜 멋지제!!@@

- 사용하는 이유?!?!?!?!왜 사용하는 것일까!@?
  - 추상적인 골격인 framework 패키지와 구체적인 내용의 idcard 패키지로 나뉘어져 있다.
    - 만약 새로운 Product 가 생성된다면 새로운 패키지를 만들고 추상적 골격을 import 해 새로운 Product 의 공장을 만들 수 있다.
    - 이 말 뜻은 framework 의 코드를 수정할 필요가 전혀 없다!
  - 인스턴스 생성 메소드의 기술 방법 3가지
    1. 추상 메소드로 구현해 자식에서 반드시 상속할 수 있도록 한다.
    2. 디폴트로 팩토리 상위 클래스에 생성한다.
       - -> 이 경우엔 Product 가 추상 클래스일 수 없다.
       ``` java
       class Factory {
         public Product createProduct(String name) {
           return new Product(name);
         }
         ...
       } 
       ```
    3. 디폴트 구현을 에러로 처리해서 구현하지 않았을 경우 에러가 발생하도록 한다.

- 어떤 디자인 패턴이든 단일 클래스의 작동 방식에 초점을 맞추면 이해를 하기 힘들다.
  - 클래스간에 어떻게 연관 관계를 맺고 유기적인 구조를 파악하는게 디자인 패턴의 이해해 더욱 큰 도움이 된다.
